defmodule Meta.Mime do
  @doc """
  Defines functions for working with MIME-types.

  Functions are autogenerated from `mimes.txt` spec.

  Check out the `Meta.Mime.Direct` module as well - it contains
  functions with names corresponding to each type, returning
  corresponding extensions list.
  """

  @type mime_type :: String.t()
  @type extension :: String.t()

  @spec exts_from_type(type :: mime_type()) :: [extension]
  @spec type_from_ext(ext :: extension()) :: mime_type() | nil

  # explicitly define the dependency on `mimes.txt`.
  # this way Mix will know that it needs to recompile this module
  # when `mimes.txt` change
  @external_resource mimes_path = Path.join(__DIR__, "mimes.txt")

  @type type_with_extensions :: {Mime.mime_type(), [Mime.extension()]}

  defmodule :__HELPERS__ do
    @moduledoc false
    # defines a function that parses a line in `mimes.txt`,
    # and returns a tuple of corresponding type and a list of its extensions.

    alias Meta.Mime

    @doc false
    @spec parse_spec_line(String.t()) :: {Mime.mime_type(), [Mime.extension()]}
    def parse_spec_line(line) do
      [type, rest] =
        line
        |> String.split(" ", trim: true)
        |> Enum.map(&String.trim/1)

      extensions = String.split(rest, ~r/,\s?/)

      {type, extensions}
    end
  end

  # define heads of &exts_from_type/1 and &type_from_ext/1
  # for each MIME-type definition from `mimes.txt`, using
  # [unquote fragements](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2-binding-and-unquote-fragments)
  for {type, extensions} <-
        File.stream!(mimes_path)
        |> Stream.map(&:__HELPERS__.parse_spec_line/1) do
    def exts_from_type(unquote(type)) do
      unquote(extensions)
    end

    def type_from_ext(ext) when ext in unquote(extensions) do
      unquote(type)
    end
  end

  @doc """
  Returns a list of extensions for a given MIME-type `type`.
  If corresponding MIME-type is found, returns `[]`.
  """
  def exts_from_type(_type), do: []

  @doc """
  Returns a MIME-type from an extension `ext`.
  If no corresponding MIME-type is found, returns `nil`.
  """
  def type_from_ext(_ext), do: nil

  @doc """
  Checks if `type` is a valid MIME-type.
  """
  @spec valid_type?(mime_type()) :: boolean()
  def valid_type?(type) do
    exts_from_type(type)
    |> Enum.any?()
  end

  defmodule Direct do
    @moduledoc """
    Defines a function returning extensions for each
    MIME-type with the name = MIME-type with underscores
    instead of slashes.
    """

    alias Meta.Mime

    for {type, extensions} <-
          File.stream!(mimes_path)
          |> Stream.map(&:__HELPERS__.parse_spec_line/1) do
      type_atom =
        type
        |> String.replace("\/", "_")
        |> String.to_atom()

      # note that docs and specs are also autogenerated!

      @doc """
      Returns extensions list for MIME-type `#{type}`.
      """
      @spec unquote(type_atom)() :: [Mime.extension()]
      def unquote(type_atom)() do
        unquote(extensions)
      end
    end
  end
end
